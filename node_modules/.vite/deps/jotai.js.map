{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\r\nfunction atom(read, write) {\r\n  const key = `atom${++keyCount}`;\r\n  const config = {\r\n    toString() {\r\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\r\n    }\r\n  };\r\n  if (typeof read === \"function\") {\r\n    config.read = read;\r\n  } else {\r\n    config.init = read;\r\n    config.read = defaultRead;\r\n    config.write = defaultWrite;\r\n  }\r\n  if (write) {\r\n    config.write = write;\r\n  }\r\n  return config;\r\n}\r\nfunction defaultRead(get) {\r\n  return get(this);\r\n}\r\nfunction defaultWrite(get, set, arg) {\r\n  return set(\r\n    this,\r\n    typeof arg === \"function\" ? arg(get(this)) : arg\r\n  );\r\n}\r\n\r\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\r\nconst hasInitialValue = (atom) => \"init\" in atom;\r\nconst isActuallyWritableAtom = (atom) => !!atom.write;\r\nconst cancelablePromiseMap = /* @__PURE__ */ new WeakMap();\r\nconst isPendingPromise = (value) => {\r\n  var _a;\r\n  return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? void 0 : _a[1]);\r\n};\r\nconst cancelPromise = (promise, nextValue) => {\r\n  const promiseState = cancelablePromiseMap.get(promise);\r\n  if (promiseState) {\r\n    promiseState[1] = true;\r\n    promiseState[0].forEach((fn) => fn(nextValue));\r\n  } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n    throw new Error(\"[Bug] cancelable promise not found\");\r\n  }\r\n};\r\nconst patchPromiseForCancelability = (promise) => {\r\n  if (cancelablePromiseMap.has(promise)) {\r\n    return;\r\n  }\r\n  const promiseState = [/* @__PURE__ */ new Set(), false];\r\n  cancelablePromiseMap.set(promise, promiseState);\r\n  const settle = () => {\r\n    promiseState[1] = true;\r\n  };\r\n  promise.then(settle, settle);\r\n  promise.onCancel = (fn) => {\r\n    promiseState[0].add(fn);\r\n  };\r\n};\r\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\r\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\r\nconst returnAtomValue = (atomState) => {\r\n  if (\"e\" in atomState) {\r\n    throw atomState.e;\r\n  }\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\r\n    throw new Error(\"[Bug] atom state is not initialized\");\r\n  }\r\n  return atomState.v;\r\n};\r\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\r\n  if (!dependencyAtomState.p.has(atom)) {\r\n    dependencyAtomState.p.add(atom);\r\n    promise.then(\r\n      () => {\r\n        dependencyAtomState.p.delete(atom);\r\n      },\r\n      () => {\r\n        dependencyAtomState.p.delete(atom);\r\n      }\r\n    );\r\n  }\r\n};\r\nconst addDependency = (pending, atom, atomState, a, aState) => {\r\n  var _a;\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a === atom) {\r\n    throw new Error(\"[Bug] atom cannot depend on itself\");\r\n  }\r\n  atomState.d.set(a, aState.n);\r\n  if (isPendingPromise(atomState.v)) {\r\n    addPendingPromiseToDependency(atom, atomState.v, aState);\r\n  }\r\n  (_a = aState.m) == null ? void 0 : _a.t.add(atom);\r\n  if (pending) {\r\n    addPendingDependent(pending, a, atom);\r\n  }\r\n};\r\nconst createPending = () => [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set()];\r\nconst addPendingAtom = (pending, atom, atomState) => {\r\n  if (!pending[0].has(atom)) {\r\n    pending[0].set(atom, /* @__PURE__ */ new Set());\r\n  }\r\n  pending[1].set(atom, atomState);\r\n};\r\nconst addPendingDependent = (pending, atom, dependent) => {\r\n  const dependents = pending[0].get(atom);\r\n  if (dependents) {\r\n    dependents.add(dependent);\r\n  }\r\n};\r\nconst getPendingDependents = (pending, atom) => pending[0].get(atom);\r\nconst addPendingFunction = (pending, fn) => {\r\n  pending[2].add(fn);\r\n};\r\nconst flushPending = (pending) => {\r\n  let error;\r\n  let hasError = false;\r\n  const call = (fn) => {\r\n    try {\r\n      fn();\r\n    } catch (e) {\r\n      if (!hasError) {\r\n        error = e;\r\n        hasError = true;\r\n      }\r\n    }\r\n  };\r\n  while (pending[1].size || pending[2].size) {\r\n    pending[0].clear();\r\n    const atomStates = new Set(pending[1].values());\r\n    pending[1].clear();\r\n    const functions = new Set(pending[2]);\r\n    pending[2].clear();\r\n    atomStates.forEach((atomState) => {\r\n      var _a;\r\n      return (_a = atomState.m) == null ? void 0 : _a.l.forEach(call);\r\n    });\r\n    functions.forEach(call);\r\n  }\r\n  if (hasError) {\r\n    throw error;\r\n  }\r\n};\r\nconst buildStore = (...[getAtomState, atomRead, atomWrite, atomOnMount]) => {\r\n  let debugMountedAtoms;\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n    debugMountedAtoms = /* @__PURE__ */ new Set();\r\n  }\r\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise) => {\r\n    const hasPrevValue = \"v\" in atomState;\r\n    const prevValue = atomState.v;\r\n    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;\r\n    if (isPromiseLike(valueOrPromise)) {\r\n      patchPromiseForCancelability(valueOrPromise);\r\n      for (const a of atomState.d.keys()) {\r\n        addPendingPromiseToDependency(atom, valueOrPromise, getAtomState(a));\r\n      }\r\n      atomState.v = valueOrPromise;\r\n      delete atomState.e;\r\n    } else {\r\n      atomState.v = valueOrPromise;\r\n      delete atomState.e;\r\n    }\r\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\r\n      ++atomState.n;\r\n      if (pendingPromise) {\r\n        cancelPromise(pendingPromise, valueOrPromise);\r\n      }\r\n    }\r\n  };\r\n  const readAtomState = (pending, atom, dirtyAtoms) => {\r\n    var _a;\r\n    const atomState = getAtomState(atom);\r\n    if (isAtomStateInitialized(atomState)) {\r\n      if (atomState.m && !(dirtyAtoms == null ? void 0 : dirtyAtoms.has(atom))) {\r\n        return atomState;\r\n      }\r\n      if (Array.from(atomState.d).every(\r\n        ([a, n]) => (\r\n          // Recursively, read the atom state of the dependency, and\r\n          // check if the atom epoch number is unchanged\r\n          readAtomState(pending, a, dirtyAtoms).n === n\r\n        )\r\n      )) {\r\n        return atomState;\r\n      }\r\n    }\r\n    atomState.d.clear();\r\n    let isSync = true;\r\n    const getter = (a) => {\r\n      if (isSelfAtom(atom, a)) {\r\n        const aState2 = getAtomState(a);\r\n        if (!isAtomStateInitialized(aState2)) {\r\n          if (hasInitialValue(a)) {\r\n            setAtomStateValueOrPromise(a, aState2, a.init);\r\n          } else {\r\n            throw new Error(\"no atom init\");\r\n          }\r\n        }\r\n        return returnAtomValue(aState2);\r\n      }\r\n      const aState = readAtomState(pending, a, dirtyAtoms);\r\n      try {\r\n        return returnAtomValue(aState);\r\n      } finally {\r\n        if (isSync) {\r\n          addDependency(pending, atom, atomState, a, aState);\r\n        } else {\r\n          const pending2 = createPending();\r\n          addDependency(pending2, atom, atomState, a, aState);\r\n          mountDependencies(pending2, atom, atomState);\r\n          flushPending(pending2);\r\n        }\r\n      }\r\n    };\r\n    let controller;\r\n    let setSelf;\r\n    const options = {\r\n      get signal() {\r\n        if (!controller) {\r\n          controller = new AbortController();\r\n        }\r\n        return controller.signal;\r\n      },\r\n      get setSelf() {\r\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\r\n          console.warn(\"setSelf function cannot be used with read-only atom\");\r\n        }\r\n        if (!setSelf && isActuallyWritableAtom(atom)) {\r\n          setSelf = (...args) => {\r\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\r\n              console.warn(\"setSelf function cannot be called in sync\");\r\n            }\r\n            if (!isSync) {\r\n              return writeAtom(atom, ...args);\r\n            }\r\n          };\r\n        }\r\n        return setSelf;\r\n      }\r\n    };\r\n    try {\r\n      const valueOrPromise = atomRead(atom, getter, options);\r\n      setAtomStateValueOrPromise(atom, atomState, valueOrPromise);\r\n      if (isPromiseLike(valueOrPromise)) {\r\n        (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());\r\n        const complete = () => {\r\n          if (atomState.m) {\r\n            const pending2 = createPending();\r\n            mountDependencies(pending2, atom, atomState);\r\n            flushPending(pending2);\r\n          }\r\n        };\r\n        valueOrPromise.then(complete, complete);\r\n      }\r\n      return atomState;\r\n    } catch (error) {\r\n      delete atomState.v;\r\n      atomState.e = error;\r\n      ++atomState.n;\r\n      return atomState;\r\n    } finally {\r\n      isSync = false;\r\n    }\r\n  };\r\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));\r\n  const getDependents = (pending, atom, atomState) => {\r\n    var _a, _b;\r\n    const dependents = /* @__PURE__ */ new Map();\r\n    for (const a of ((_a = atomState.m) == null ? void 0 : _a.t) || []) {\r\n      dependents.set(a, getAtomState(a));\r\n    }\r\n    for (const atomWithPendingPromise of atomState.p) {\r\n      dependents.set(\r\n        atomWithPendingPromise,\r\n        getAtomState(atomWithPendingPromise)\r\n      );\r\n    }\r\n    (_b = getPendingDependents(pending, atom)) == null ? void 0 : _b.forEach((dependent) => {\r\n      dependents.set(dependent, getAtomState(dependent));\r\n    });\r\n    return dependents;\r\n  };\r\n  function getSortedDependents(pending, rootAtom, rootAtomState) {\r\n    const sorted = [];\r\n    const visiting = /* @__PURE__ */ new Set();\r\n    const visited = /* @__PURE__ */ new Set();\r\n    const stack = [[rootAtom, rootAtomState]];\r\n    while (stack.length > 0) {\r\n      const [a, aState] = stack[stack.length - 1];\r\n      if (visited.has(a)) {\r\n        stack.pop();\r\n        continue;\r\n      }\r\n      if (visiting.has(a)) {\r\n        sorted.push([a, aState, aState.n]);\r\n        visited.add(a);\r\n        stack.pop();\r\n        continue;\r\n      }\r\n      visiting.add(a);\r\n      for (const [d, s] of getDependents(pending, a, aState)) {\r\n        if (a !== d && !visiting.has(d)) {\r\n          stack.push([d, s]);\r\n        }\r\n      }\r\n    }\r\n    return [sorted, visited];\r\n  }\r\n  const recomputeDependents = (pending, atom, atomState) => {\r\n    const [topsortedAtoms, markedAtoms] = getSortedDependents(\r\n      pending,\r\n      atom,\r\n      atomState\r\n    );\r\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\r\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\r\n      const [a, aState, prevEpochNumber] = topsortedAtoms[i];\r\n      let hasChangedDeps = false;\r\n      for (const dep of aState.d.keys()) {\r\n        if (dep !== a && changedAtoms.has(dep)) {\r\n          hasChangedDeps = true;\r\n          break;\r\n        }\r\n      }\r\n      if (hasChangedDeps) {\r\n        readAtomState(pending, a, markedAtoms);\r\n        mountDependencies(pending, a, aState);\r\n        if (prevEpochNumber !== aState.n) {\r\n          addPendingAtom(pending, a, aState);\r\n          changedAtoms.add(a);\r\n        }\r\n      }\r\n      markedAtoms.delete(a);\r\n    }\r\n  };\r\n  const writeAtomState = (pending, atom, ...args) => {\r\n    let isSync = true;\r\n    const getter = (a) => returnAtomValue(readAtomState(pending, a));\r\n    const setter = (a, ...args2) => {\r\n      const aState = getAtomState(a);\r\n      try {\r\n        if (isSelfAtom(atom, a)) {\r\n          if (!hasInitialValue(a)) {\r\n            throw new Error(\"atom not writable\");\r\n          }\r\n          const prevEpochNumber = aState.n;\r\n          const v = args2[0];\r\n          setAtomStateValueOrPromise(a, aState, v);\r\n          mountDependencies(pending, a, aState);\r\n          if (prevEpochNumber !== aState.n) {\r\n            addPendingAtom(pending, a, aState);\r\n            recomputeDependents(pending, a, aState);\r\n          }\r\n          return void 0;\r\n        } else {\r\n          return writeAtomState(pending, a, ...args2);\r\n        }\r\n      } finally {\r\n        if (!isSync) {\r\n          flushPending(pending);\r\n        }\r\n      }\r\n    };\r\n    try {\r\n      return atomWrite(atom, getter, setter, ...args);\r\n    } finally {\r\n      isSync = false;\r\n    }\r\n  };\r\n  const writeAtom = (atom, ...args) => {\r\n    const pending = createPending();\r\n    try {\r\n      return writeAtomState(pending, atom, ...args);\r\n    } finally {\r\n      flushPending(pending);\r\n    }\r\n  };\r\n  const mountDependencies = (pending, atom, atomState) => {\r\n    if (atomState.m && !isPendingPromise(atomState.v)) {\r\n      for (const a of atomState.d.keys()) {\r\n        if (!atomState.m.d.has(a)) {\r\n          const aMounted = mountAtom(pending, a, getAtomState(a));\r\n          aMounted.t.add(atom);\r\n          atomState.m.d.add(a);\r\n        }\r\n      }\r\n      for (const a of atomState.m.d || []) {\r\n        if (!atomState.d.has(a)) {\r\n          atomState.m.d.delete(a);\r\n          const aMounted = unmountAtom(pending, a, getAtomState(a));\r\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  const mountAtom = (pending, atom, atomState) => {\r\n    if (!atomState.m) {\r\n      readAtomState(pending, atom);\r\n      for (const a of atomState.d.keys()) {\r\n        const aMounted = mountAtom(pending, a, getAtomState(a));\r\n        aMounted.t.add(atom);\r\n      }\r\n      atomState.m = {\r\n        l: /* @__PURE__ */ new Set(),\r\n        d: new Set(atomState.d.keys()),\r\n        t: /* @__PURE__ */ new Set()\r\n      };\r\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n        debugMountedAtoms.add(atom);\r\n      }\r\n      if (isActuallyWritableAtom(atom)) {\r\n        const mounted = atomState.m;\r\n        let setAtom;\r\n        const createInvocationContext = (pending2, fn) => {\r\n          let isSync = true;\r\n          setAtom = (...args) => {\r\n            try {\r\n              return writeAtomState(pending2, atom, ...args);\r\n            } finally {\r\n              if (!isSync) {\r\n                flushPending(pending2);\r\n              }\r\n            }\r\n          };\r\n          try {\r\n            return fn();\r\n          } finally {\r\n            isSync = false;\r\n          }\r\n        };\r\n        addPendingFunction(pending, () => {\r\n          const onUnmount = createInvocationContext(\r\n            pending,\r\n            () => atomOnMount(atom, (...args) => setAtom(...args))\r\n          );\r\n          if (onUnmount) {\r\n            mounted.u = (pending2) => createInvocationContext(pending2, onUnmount);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return atomState.m;\r\n  };\r\n  const unmountAtom = (pending, atom, atomState) => {\r\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\r\n      var _a;\r\n      return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);\r\n    })) {\r\n      const onUnmount = atomState.m.u;\r\n      if (onUnmount) {\r\n        addPendingFunction(pending, () => onUnmount(pending));\r\n      }\r\n      delete atomState.m;\r\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n        debugMountedAtoms.delete(atom);\r\n      }\r\n      for (const a of atomState.d.keys()) {\r\n        const aMounted = unmountAtom(pending, a, getAtomState(a));\r\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\r\n      }\r\n      return void 0;\r\n    }\r\n    return atomState.m;\r\n  };\r\n  const subscribeAtom = (atom, listener) => {\r\n    const pending = createPending();\r\n    const atomState = getAtomState(atom);\r\n    const mounted = mountAtom(pending, atom, atomState);\r\n    const listeners = mounted.l;\r\n    listeners.add(listener);\r\n    flushPending(pending);\r\n    return () => {\r\n      listeners.delete(listener);\r\n      const pending2 = createPending();\r\n      unmountAtom(pending2, atom, atomState);\r\n      flushPending(pending2);\r\n    };\r\n  };\r\n  const unstable_derive = (fn) => buildStore(...fn(getAtomState, atomRead, atomWrite, atomOnMount));\r\n  const store = {\r\n    get: readAtom,\r\n    set: writeAtom,\r\n    sub: subscribeAtom,\r\n    unstable_derive\r\n  };\r\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n    const devStore = {\r\n      // store dev methods (these are tentative and subject to change without notice)\r\n      dev4_get_internal_weak_map: () => ({\r\n        get: (atom) => {\r\n          const atomState = getAtomState(atom);\r\n          if (atomState.n === 0) {\r\n            return void 0;\r\n          }\r\n          return atomState;\r\n        }\r\n      }),\r\n      dev4_get_mounted_atoms: () => debugMountedAtoms,\r\n      dev4_restore_atoms: (values) => {\r\n        const pending = createPending();\r\n        for (const [atom, value] of values) {\r\n          if (hasInitialValue(atom)) {\r\n            const atomState = getAtomState(atom);\r\n            const prevEpochNumber = atomState.n;\r\n            setAtomStateValueOrPromise(atom, atomState, value);\r\n            mountDependencies(pending, atom, atomState);\r\n            if (prevEpochNumber !== atomState.n) {\r\n              addPendingAtom(pending, atom, atomState);\r\n              recomputeDependents(pending, atom, atomState);\r\n            }\r\n          }\r\n        }\r\n        flushPending(pending);\r\n      }\r\n    };\r\n    Object.assign(store, devStore);\r\n  }\r\n  return store;\r\n};\r\nconst createStore = () => {\r\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\r\n  const getAtomState = (atom) => {\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\r\n      throw new Error(\"Atom is undefined or null\");\r\n    }\r\n    let atomState = atomStateMap.get(atom);\r\n    if (!atomState) {\r\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\r\n      atomStateMap.set(atom, atomState);\r\n    }\r\n    return atomState;\r\n  };\r\n  return buildStore(\r\n    getAtomState,\r\n    (atom, ...params) => atom.read(...params),\r\n    (atom, ...params) => atom.write(...params),\r\n    (atom, ...params) => {\r\n      var _a;\r\n      return (_a = atom.onMount) == null ? void 0 : _a.call(atom, ...params);\r\n    }\r\n  );\r\n};\r\nlet defaultStore;\r\nconst getDefaultStore = () => {\r\n  if (!defaultStore) {\r\n    defaultStore = createStore();\r\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\r\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\r\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\r\n        console.warn(\r\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return defaultStore;\r\n};\r\n\r\nexport { atom, createStore, getDefaultStore };\r\n", "'use client';\r\nimport ReactExports, { createContext, useRef, createElement, useContext, useReducer, useEffect, useDebugValue, useCallback } from 'react';\r\nimport { createStore, getDefaultStore } from 'jotai/vanilla';\r\n\r\nconst StoreContext = createContext(\r\n  void 0\r\n);\r\nconst useStore = (options) => {\r\n  const store = useContext(StoreContext);\r\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\r\n};\r\nconst Provider = ({\r\n  children,\r\n  store\r\n}) => {\r\n  const storeRef = useRef();\r\n  if (!store && !storeRef.current) {\r\n    storeRef.current = createStore();\r\n  }\r\n  return createElement(\r\n    StoreContext.Provider,\r\n    {\r\n      value: store || storeRef.current\r\n    },\r\n    children\r\n  );\r\n};\r\n\r\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\r\nconst attachPromiseMeta = (promise) => {\r\n  promise.status = \"pending\";\r\n  promise.then(\r\n    (v) => {\r\n      promise.status = \"fulfilled\";\r\n      promise.value = v;\r\n    },\r\n    (e) => {\r\n      promise.status = \"rejected\";\r\n      promise.reason = e;\r\n    }\r\n  );\r\n};\r\nconst use = ReactExports.use || ((promise) => {\r\n  if (promise.status === \"pending\") {\r\n    throw promise;\r\n  } else if (promise.status === \"fulfilled\") {\r\n    return promise.value;\r\n  } else if (promise.status === \"rejected\") {\r\n    throw promise.reason;\r\n  } else {\r\n    attachPromiseMeta(promise);\r\n    throw promise;\r\n  }\r\n});\r\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\r\nconst createContinuablePromise = (promise) => {\r\n  let continuablePromise = continuablePromiseMap.get(promise);\r\n  if (!continuablePromise) {\r\n    continuablePromise = new Promise((resolve, reject) => {\r\n      let curr = promise;\r\n      const onFulfilled = (me) => (v) => {\r\n        if (curr === me) {\r\n          resolve(v);\r\n        }\r\n      };\r\n      const onRejected = (me) => (e) => {\r\n        if (curr === me) {\r\n          reject(e);\r\n        }\r\n      };\r\n      const registerCancelHandler = (p) => {\r\n        if (\"onCancel\" in p && typeof p.onCancel === \"function\") {\r\n          p.onCancel((nextValue) => {\r\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && nextValue === p) {\r\n              throw new Error(\"[Bug] p is not updated even after cancelation\");\r\n            }\r\n            if (isPromiseLike(nextValue)) {\r\n              continuablePromiseMap.set(nextValue, continuablePromise);\r\n              curr = nextValue;\r\n              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\r\n              registerCancelHandler(nextValue);\r\n            } else {\r\n              resolve(nextValue);\r\n            }\r\n          });\r\n        }\r\n      };\r\n      promise.then(onFulfilled(promise), onRejected(promise));\r\n      registerCancelHandler(promise);\r\n    });\r\n    continuablePromiseMap.set(promise, continuablePromise);\r\n  }\r\n  return continuablePromise;\r\n};\r\nfunction useAtomValue(atom, options) {\r\n  const store = useStore(options);\r\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\r\n    (prev) => {\r\n      const nextValue = store.get(atom);\r\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\r\n        return prev;\r\n      }\r\n      return [nextValue, store, atom];\r\n    },\r\n    void 0,\r\n    () => [store.get(atom), store, atom]\r\n  );\r\n  let value = valueFromReducer;\r\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\r\n    rerender();\r\n    value = store.get(atom);\r\n  }\r\n  const delay = options == null ? void 0 : options.delay;\r\n  useEffect(() => {\r\n    const unsub = store.sub(atom, () => {\r\n      if (typeof delay === \"number\") {\r\n        const value2 = store.get(atom);\r\n        if (isPromiseLike(value2)) {\r\n          attachPromiseMeta(createContinuablePromise(value2));\r\n        }\r\n        setTimeout(rerender, delay);\r\n        return;\r\n      }\r\n      rerender();\r\n    });\r\n    rerender();\r\n    return unsub;\r\n  }, [store, atom, delay]);\r\n  useDebugValue(value);\r\n  if (isPromiseLike(value)) {\r\n    const promise = createContinuablePromise(value);\r\n    return use(promise);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction useSetAtom(atom, options) {\r\n  const store = useStore(options);\r\n  const setAtom = useCallback(\r\n    (...args) => {\r\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\r\n        throw new Error(\"not writable atom\");\r\n      }\r\n      return store.set(atom, ...args);\r\n    },\r\n    [store, atom]\r\n  );\r\n  return setAtom;\r\n}\r\n\r\nfunction useAtom(atom, options) {\r\n  return [\r\n    useAtomValue(atom, options),\r\n    // We do wrong type assertion here, which results in throwing an error.\r\n    useSetAtom(atom, options)\r\n  ];\r\n}\r\n\r\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\r\n"],
  "mappings": "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",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
